# teach-yourself-cs-curriculum

## Intro

This document is my record of work towards a Self-Taught equivalent of a CS degree. I want to pursue mastery in my craft and the aim for this project that will most likely span years is to keep track and log of all things and be able to share it with people who could benefit form it. The core curriculum is as perscribed by Oz Nova and Myles Byrne, authors of [teachyourselfcs.com](https://teachyourselfcs.com), but consists of many additional resources that I have completed / am interested in. If you want to ask questions about the core curriculum, all the answers are to be found at the link above. The files in this repository are a collection of all the possible files, notes, etc. that I have been using for my work. It's a snapshot of a real-life workplace, with various papers and books scattered around than a repository of coherent code, and it should be treated as such. Use it to guess my process, look at resources I've worked on, etc.

The purpose of this repository is twofold - to keep myself organised and accountable, and also to be able to share my experience with other people who are undertaking a similar challenge of completing this curriculum.

## Summer 2021 Update

Time flies. I've been working on my cs knowledge since Dec 2020, and ATOW it's August 2021. Since then I've actually enrolled in a [intensive computer science course offered by Bradfield](https://bradfieldcs.com/csi/). For transparency - it's offered by the authors of the [teachyourselfcs](https://teachyourselfcs.com) curriculum. That means that the title of this repository, and by extension, the actual notion of teaching _yourself_ cs changes a little bit, since I'm actually enrolled in an institution where I'm being taught. Nonetheless, I am going to keep maintaining it for visibility, inspiration, accountability, and numerous other reasons, and I'm sure its maintenance will outlive taking that course.

For those of you who found this repository since I have started it and messaged me about it - thank you, I'm glad it's inspiring action! Although I do often come here to add blog-like notes like this, it is more likely to happen on [my blog](https://reversepolishnotation.com).

Anyhow, that's all for now. Good times ahead. Updates to follow.

Over and out.

## Table of Contents

- [Progress](#progress)
- [General Findings](#general-findings)
- [Notes on different parts of the course](#course)
- [References](#references)

## Progress

Here's a list of all courses I'm planning to take. They're mostly taken from the [tycs](teachyourselfcs.com) website, which I'm treating as a central point of my curriculum, but I've been adding other resources as I was exploring varous avenues. The content and topics vary, and over the months of maintaining this list I have found myself diverting form the original course, and coming back, and generally noting down things that I've done, cause they were interesting at the time. I became a record of my interests. _update August 2021_: Also, it hosts a scrapbook notepad of my notes from [Bradfield](https://bradfieldcs.com/csi).

### Completed

#### 2020

- [x] (book) [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS), by [getify](https://github.com/getify) books 1-6. Absolutely an amazing piece of work on JS. Highly recommend.
- [x] (book) [C.O.D.E](https://en.wikipedia.org/wiki/Code:_The_Hidden_Language_of_Computer_Hardware_and_Software) by [Charles Petzold](https://www.charlespetzold.com/). Stunning book on the nature of computers, clear explanations, great storytelling.
- [x] (book/video course) [Learn C the Hard Way](https://shop.learncodethehardway.org) by [Zed Shaw](https://twitter.com/lzsthw). I've learned a lot about modern C programming from Zed, but more importantly, good habits. The learning methodology really stuck with me and pays dividends on all learning since. I highly recommend it even just for that reason.
- [x] (mooc + book) [Learning How To Learn](https://www.coursera.org/learn/learning-how-to-learn) and [A Mind for Numbers](https://barbaraoakley.com/books/a-mind-for-numbers/) by [Barbara Oakley](https://barbaraoakley.com/). Transforming course and a book. Understanding the neuroscience behind learning has helped me treat a lot of imposter syndrome and made my learning more efficient.

#### 2021

- [x] (book) [Effective C](https://nostarch.com/Effective_C). A thorough look at C - provided great commentary and supplimented a lot of knowledge in a very clear way. Recommend.
- [x] (book) [The C Programming Language](https://en.wikipedia.org/wiki/The_C_Programming_Language). Absolute classic, great peek into the 'past', but I found myself not being the target audience. Only used it correctly after Zed Shaw's resources and reading Effective C. Still a valuable read.
- [x] (book) [Good Math](https://www.amazon.com/Good-Math-Computation-Pragmatic-Programmers/dp/1937785335). I've been shying away from maths most of my life, and this book is one of the reasons I've turned around to the beauty of Mathematics.
- [x] (mooc) [Information Representation in Computer Systems](https://www.educative.io/courses/information-representation-computer-systems). Sounded great, but ended up being very superficial and kinda put together in a rush. One of many resources from educative that I tried and wasn't happy with. Their content is a hit or miss, still, the coding interview prep resources are quite decent, and I can see the resources quality grow over a few months since I started my subscription so don't write them off just yet.
- [x] (book) [Practical Algorithms](https://bradfieldcs.com/algos/)
- [x] (book) [Beginning Ruby 3 from Beginner to Pro](https://www.apress.com/gp/book/9781484263235) Ruby was a in-and-out favourite language of mine and I am so happy to have revisited it. That book was a great help and came to be especially useful due to inclusion of an appendix that gives you a crash course in Ruby if you're not new to programming and a great library overview.
- [x] (book) [Practical SQL](https://www.amazon.com/Practical-SQL-Beginners-Guide-Storytelling/dp/1593278276)
- [x] (course) [Algoexpert - Systems Expert](https://www.algoexpert.io) Very good content, highly recommend.
- [x] (book) [A Mathematician's Lament by Paul Lockhart](https://www.maa.org/external_archive/devlin/LockhartsLament.pdf) A very valuable read. I've linked just the essay but I recommend the whole book. Easily findable on Amazon.
- [x] (paper) [The Unreasonable Efectiveness of Mathematics by RW Hamming](<https://web.njit.edu/~akansu/PAPERS/The%20Unreasonable%20Effectiveness%20of%20Mathematics%20(RW%20Hamming).pdf>) Absolutely incredible read.
- [x] (book) [Hackers and Painters by Paul Graham](https://www.amazon.com/Hackers-Painters-Big-Ideas-Computer/dp/1449389554) A little oudated, more of a history lesson and a book-long rant on programming language design. I found it valuable and entertaining.
- [x] (course) [CSS in Depth, v2](https://frontendmasters.com/courses/css-in-depth-v2/) Admit it, you've been avoiding CSS a lot didn't you? I did. Not anymore.
- [x] (video) [What is a File Format?](https://www.youtube.com/watch?v=VVdmmN0su6E) Quick watch that may teach you a lot about files even if you think you know a bit or two.
- [x] (course) [Tree and Graph Data Structures](https://frontendmasters.com/courses/trees-and-graphs) A course that doesn't go in as much depth as I'd like it to, but has helped in re-hashing a few things and enabled me to organize some knowledge in my mind.
- [x] (book) [The Secret Life of Programs: Understand Computers -- Craft Better Code by Jonathan E. Steinheart](https://www.amazon.com/Secret-Life-Programs-Understand-Computers-ebook/dp/B07PCKLDW1) **VERY IMPORTANT READ**. Along with C.O.D.E (see above), two of the most important books that I've encountered so far. Full of great details about things that really matter. Every page is packed with crucial, well described information.
- [x] (book) [The Art of Invisibility](https://www.audible.com/pd/The-Art-of-Invisibility-Audiobook/B01N80UK3J?ref=a_library_t_c5_libItem_&pf_rd_p=80765e81-b10a-4f33-b1d3-ffb87793d047&pf_rd_r=Y6WZCF3162D418HPWH4W). Not a computer science book, but a very interesting read. I found to have known most of the things Mitnick is talking about but it was an entertaning read.
- [x] (book) [This Is How They Tell Me The World Ends](https://www.audible.com/pd/This-Is-How-They-Tell-Me-the-World-Ends-Audiobook/1635577179?ref=a_library_t_c5_libItem_&pf_rd_p=80765e81-b10a-4f33-b1d3-ffb87793d047&pf_rd_r=Y6WZCF3162D418HPWH4W). Thrilling. If you ever listened to Darknet Diaries, you will like this. Again, not a CS book or edcuation per se, but a gripping story on the threshold of politics and computers.
- [x] (book) [Sandworm - A New Era of Cyberwar](https://www.audible.com/pd/Sandworm-Audiobook/0593146786?ref=a_library_t_c5_libItem_&pf_rd_p=80765e81-b10a-4f33-b1d3-ffb87793d047&pf_rd_r=Y6WZCF3162D418HPWH4W) Last entry in a row of three books on ifnosec I've literally devoured one after another. Great pace, covers in detail parts of "This Is How They Tell Me The World Ends", going deeper on a specific hacking group.
- [x] (book) [Discrete Mathematics lecture notes by Laszlo Lovasz (direct download)](http://www.cs.elte.hu/~lovasz/dmbook.ps)

### Currently working on

Notes regarding that are on [my blog](https://reversepolishnotation.com). I've moved my attention there. May come back to this list approach later. I still see value in that list I've collated here, maybe it'll get resurrected.

### Next in line
- [ ] (video course) [MIT 6.042J Mathematics for Computer Science](https://www.youtube.com/watch?v=L3LMbpZIKhQ&list=PLB7540DEDD482705B)
- [ ] (book) [Designing Data-Intensive Applications](https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321)
- [ ] (book) [Linux Programming Interface](https://www.amazon.com/Linux-Programming-Interface-System-Handbook/dp/1593272200/ref=sr_1_3?dchild=1&keywords=linux+programming+interface&qid=1628305669&sr=8-3)
- [ ] (book) [The Go Programming Language](https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440) Done for my coursework at Bradfield, and I am happy I stumbled upon it. Go feels great, is very similar to C, but "better" in many ways. I've enjoyed learning about it. The book itself is very challenge oriented, there's plenty of examples, and very similarly to K&R, you're probably going to learn a lot about computer science when learning Go, if you're not v. advanced. I really liked it.
- [ ] (course) I've found a [great resource from Yale University](http://cs.yale.edu/homes/aspnes/classes/223/notes.html) on Data Structures and Programming Techniques, all in C. I am very skeptical about being able to finish it within the time boundaries I'm working with but hey, it's a good aspirational bit.
- [ ] (book) [Programming Typescript](https://www.oreilly.com/library/view/programming-typescript/9781492037644/)
- [ ] (course) [Complete Intro to Databases](https://frontendmasters.com/courses/databases/)
- [ ] (book) [Interactive Linear Algebra](http://textbooks.math.gatech.edu/ila/overview.html)
- [ ] (course) [Algoexpert - AlgoExpert - 160 questions](https://www.algoexpert.io)
- [ ] (course) [VIM fundamentals](https://frontendmasters.com/courses/vim-fundamentals)
- [ ] (project + book) [Arduino Projects Book](https://bastiaanvanhengel.files.wordpress.com/2016/06/arduino_projects_book.pdf)
- [ ] (book) [Grokking Algorithms](https://www.manning.com/books/grokking-algorithms)
- [ ] (book) [The Effective Engineer]()
- [ ] (book) [Clean Code]()
- [ ] (book) [Code Complete]()
- [ ] (book) [Software Engineering at Google]()
- [ ] (book) [Calculus By and For Young People]()
- [ ] (book) [Ther Pragmatic Programmer]()
- [ ] (challenge) [advent of code (all years, all challenges](https://adventofcode.com)
- [ ] (book)[Shotts, Linux Command Line](http://linuxcommand.org/tlcl.php)
- [ ] (book) [Practical Vim: Edit Text at the Speed of Thought](https://www.amazon.com/Practical-Vim-Edit-Speed-Thought/dp/1680501275/) I've been using `vim` for everything I do for a while now, and it's great, but I know there's so much more to discover.
- [ ] (book) [Composing Programs](https://composingprograms.com) Alternative to SICP as per the tycs guide, using Python as examples. I have attempted it early on in the process and didn't like it - the textbook itself is quite dry as it is intended to be used as a textbook alongside an actual course. If I can get access to good quality videos from the CS61A lectures I will probably finish it at a later date.
- [ ] (video) [CS 186 - DBMS](https://www.youtube.com/user/CS186Berkeley/playlists) This series of database lectures videos I have postponed working with, similarly as Composing Programs, it is intended to be used alongside the course, and that is something to solve for.
- [ ] (book) [Cracking the Coding Interview](https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850) Interviewing is a controversial topic, and this books is the holy grail of a _certain_ kind of interviewing methodology. I am intending to go through most of them, and although it focuses on Java and many challenges are deeply connected to Java and don't translate to _any_ language, studying bits of it, I found great use of the solutions and other explanations of the _attitude_ of solving those problems, moreso than the actual problems themselves, so I am planning to give it a go.
- [ ] (book) [Computer Systems, a Programmer's Perspective](http://csapp.cs.cmu.edu/3e/home.html) I've started reading it and it's a leviathan of a book - great in size, and quite dense, but nicely laid out. I'm yet to decide how to approach working with such a large text in a way that makes it most useful. Mostly using it as a reference.
- [ ] (course)[Mathematical Thinking in Computer Science](https://www.coursera.org/learn/what-is-a-proof/home/welcome)
- [ ] (book) [Algorithm Design Manual](https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/?pldnSite=1)
- [ ] (videos) [Gynvael Coldwind's YT Channel, selected content](https://www.youtube.com/watch?v=MM4hDpzFUcA)
- [ ] [How to Solve It](https://www.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069111966X)
- [ ] [Discrete Mathematics, Lovasz](https://cims.nyu.edu/~regev/teaching/discrete_math_fall_2005/dmbook.pdf)
- [ ] [Operating Systems - Three Easy Pieces](https://pages.cs.wisc.edu/~remzi/OSTEP/)
- [ ] [(only available in Polish) Zrozumiec Programowanie](https://ksiegarnia.pwn.pl/Zrozumiec-programowanie,688790689,p.html)
- [ ] [Computer Networking: A Top-Down Approach](https://www.amazon.com/Computer-Networking-Top-Down-Approach-7th/dp/0133594149)
- [ ] [Crafting Interpreters](https://craftinginterpreters.com/)
- [ ] [100 LeetCode Questions](https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850)
- [ ] [Advent of Code - all challenges from years 2015-2020](https://adventofcode.com/)
- [ ] [Oh shit git](https://wizardzines.com/zines/oh-shit-git/)
- [ ] [tmux 2 - Productive Mouse-Free Development](https://pragprog.com/titles/bhtmux2/tmux-2/)
- [ ] [Introducing Python](https://www.amazon.com/Introducing-Python-Modern-Computing-Packages/dp/1492051365)
- [ ] [Python for Programmers (educative)](https://www.educative.io/path/python-for-programmers)
- [ ] [Python Data Analysis and Visualisation (educative)](https://www.educative.io/path/python-data-analysis)
- [ ] [Ace the Python Coding Interview (educative)](https://www.educative.io/path/ace-python-coding-interview)
- [ ] [Scalability & System Design for Developers (educative)](https://www.educative.io/path/scalability-system-design)
- [ ] [DevOps for Developers (educative)](https://www.educative.io/path/devops-for-developers)
- [ ] (book) [Annotated Turing](https://www.charlespetzold.com/books/) by [Charles Petzold](https://www.charlespetzold.com/)
- [ ] [Structure and Implementation of Computer Programs](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html)
- [ ] [Brian Harvey's Berkeley CS 61A](https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter)
- [ ] [Berkeley CS 61C](https://teachyourselfcs.com/)
- [ ] [Steven Skiena's Lectures](https://teachyourselfcs.com/)
- [ ] [Mathematics for Computer Science](https://teachyourselfcs.com/)
- [ ] [Tom Leighton's MIT 6.042J](https://teachyourselfcs.com/)
- [ ] [Berkeley CS 162](https://teachyourselfcs.com/)
- [ ] [Stanford CS 144](https://teachyourselfcs.com/)
- [ ] [Readings in Database Systems](https://teachyourselfcs.com/)
- [ ] [Alex Aiken's course on Languages and Compilers](https://teachyourselfcs.com/)
- [ ] [MIT 6.824 Distributed Systems](https://teachyourselfcs.com/)
- [ ] [MIT Missing Semester](https://missing.csail.mit.edu/)
- [ ] [CS50](blank)
- [ ] [Mathematical Thinking in Computer Science](https://www.coursera.org/learn/what-is-a-proof/home/welcome)
- [ ] [One Lone Coder's Youtube Channel](https://www.youtube.com/channel/UC-yuWVUplUJZvieEligKBkA)
- [ ] [Coding Train]()

## General Findings

### Biggest Challenges

By far the most challenging part of taking a self-guided course like this is not doing it with other people. I have started a Discord Server (now not very active) for people who are also working through that curriculum, and it is helpful to exchange experiences and advice. Be ready for a lot of frustration trying to find solutions to your problems without a centralised place for people who are doing something similar hang out. Luckily there are groups centered around various resources and topics (SICP has a big community).

### First few weeks

Working through the first month of the curriculum has been a challenge - especially in guiding my learning and scheduling sessions. Working on your own you have to answer questions regarding what to study, for how long, and what are measurable deliverables. I've iterated over a few frameworks and I've found that having a clear view of a week ahead with a minimum goal works best for me. The study topics are organised in sections as per the teachyourselfcs curriculum, so for example:

I'm working through the Programming section, directly on Composing Programs, therefore every day I spend 3-5h on the main topic. To add variety, and for pleasure of it (I find it brings me the most joy to do) I also schedule daily code challenge sessions (leetcode / codewars / advent of code etc). That takes up a couple hours, and I use it to not only brush up on Algorithms, Data Structures, and Problem Solving, but also polish a language of my choice that I'm currently working with. As a tetriary topic of the day I include meta-study, on the tooling that I am using. [Therefore there's always a 30-60 minute session on vim / tmux / shell scripting etc.](#rethinking-development-process-and-tooling). Lastly, I make sure to review [recent knowledge.](#flashcards-flashcards-flashcards)

### Flashcards, flashcards, flashcards.

I'm using a [tool called Anki](https://apps.ankiweb.net/) to organise my knowledge into bite-sized reviewable flashcards. It's an incredible and simple tool that enabled me to actually retrieve a lot of knowledge. Simply as I read / watch / code, every time I stumble upon a nugget of information, I distill it to a fact, write it down into the flashcard database and review them daily. Time invested in those is worth its weight in gold for me.

### Rethinking development process and tooling

A few weeks in it became clear that counting on inspiration and good mood for learning is not enough, and so to ensure that I progress at a rate I'd like to, I had to put a few systems in place. As most of the challenges I'm facing are due to the nature of self-learning, most advice here is on how to stay motivated and engaged without outside stimuli and accountability.

- Rule of thumb: There is always something to learn. A few years ago at a startup I worked at, a colleague of mine said a phrase that went something like that: "I refuse to believe that there is nothing to do here". We were talking about a colleague of ours who quite frankly was straight down slacking for hours, but the context aside, the phrase stuck with me. The point discussed was the notion of feeling responsible and proud about the work being done. I found myself slacking for hours or sometimes days, purely due to a lack of sense of ownership of my learning. Formalizing my processes and holding myself accountable to a schedule and deliverables changed everything. To re-coin the phrase: "If you care about your work, I refuse to believe there was nothing you could do that day to move towards what you want to achieve."
- Every day, after I complete my work I do a very quick evaluation of what I think I achieved (often differs from what I've actually done) vs what I intended to do, and whether I feel proud of my efforts today. Learning is often so fuzzy and without specific boundaries, that it's easy to feel like you're under-achieving. Keeping myself in check with daily mini-retros and one at the end of every week fixes that problem.
- When facing a lot of new information and feeling discouraged about having trouble 'getting it', I learned to persevere and continue learning. Having learned about how brains process new information from [A Mind for Numbers](https://www.amazon.com/Mind-Numbers-Science-Flunked-Algebra-ebook/dp/B00G3L19ZU) I have developed a process of immersing myself in the topic nonetheless. To get more comfortable with a topic I can't fully understand I work through it from various angles, whether it be drawing things out on paper or whiteboard, trying to explain it to a friend, coding out my own solutions and implementations, etc. It feels weird and forced, but after a few days of focusing on the topic, whatever it could be, there is no way you won't start feeling familiar with it and the discomfort disappears. And with it, comes confidence and knowledge.

Working on the core Computer Science content is one thing, but becoming more proficient with the tooling while doing so is a completely different topic. I've been used to working in VSCode + separate terminal setup, but due to the fact that I am working on two different computers often (macos and linux), I need a reliable and replicable setup on both machines. For that reason I have narrowed the text editing and all work on a computer to using `tmux`, and `vim`. If you're not sure where to start with that, [I suggest a great series of video lectures](https://www.youtube.com/channel/UCuXy5tCgEninup9cGplbiFw).

One example of a simple gain is to use a tool like [nodemon](https://github.com/remy/nodemon) to speed up iteration through the coding challenges / exercises. Do not ignore it for just being a JS tool, take a look at the documentation and the `--exec` flag.

### (newfound) Love for Mathematics

I always steered away from was mathematics. I've fallen in love with it this time around, mostly thanks to a few things that have made it way more applicable, relevant, and fun. If you're feeling iffy about maths, make sure to read [Mathematician's Lament](https://www.maa.org/sites/default/files/pdf/devlin/LockhartsLament.pdf), watch a video on the [Mandelbrot Set](https://www.youtube.com/watch?v=56gzV0od6DU), and read about [The Library of Babel](https://libraryofbabel.info/) (do not forget to read the [original story](https://sites.evergreen.edu/politicalshakespeares/wp-content/uploads/sites/226/2015/12/Borges-The-Library-of-Babel.pdf). Those are the things that I have found enjoyable and were the tipping point. They may not be this for you, so just keep looking. Mathematics is a beautiful art form and I'm sure you can find that.

One thing that was very challenging early on was writing proofs. Here's a list of resources I've used to get more advice and support:

- [Writing Mathematical Proofs](https://www.hamilton.edu/documents/Writing%20Mathematical%20Proofs.pdf)
- [How to Write Proofs](http://zimmer.csufresno.edu/~larryc/proofs/proofs.html)
- [Advice for Students Writing Proofs](https://www.d.umn.edu/~jgallian/Proofs.html)

### Command Line tools i highly recommend

All should be supported under most unix systems.

- `fzf` for fuzzy matching searches in text files. a good alternative to grep/ripgrep for quick searches
- `broot` for a very neat alternative to `ls -R` or `tree` commands
- `nnn` a more advanced alt to `broot`
- `ranger` for navigating files with `vi` bindings
- `tldr` for snippets of usage examples of tools, saves you stackoverflow googling
- `pretzo` [for a really pretty](https://github.com/sorin-ionescu/prezto) `zsh` prompt.

### Course

Various notes from the course content, that I will probably want to look up later.

#### Programming

#### Composing Programs

I found [this article](https://accu.org/journals/overload/16/86/golodetz_1506/) useful while digesting Partition Trees described in section 2.3.6. Excerpt:

A partition tree is a way of representing a hierarchy of these partitions of an entity. The way it works is as follows:

- Each node in the tree represents a part of the whole entity. In particular, the root node of the tree represents the entity in its entirety.
- As is usual with trees in computer science, a node is either a branch node or a leaf node. (The distinction is that a branch node has child nodes, whereas a leaf has none.) In a partition tree, the children of a branch node represent a partition of the branch node (properly speaking, the parts of the entity represented by the children of the branch node represent a partition of the part of the entity represented by the branch node, but continually distinguishing between nodes and the sub-entities they represent is tedious).
- Each layer in the hierarchy represents a partition of the entire entity.

Using our pizza analogy, we could imagine first dividing our pizza into three portions, one for each person at the table. Each person's portion is then further sub-divided into four slices. Each person's slices are a partition of their portion, and the portions are a partition of the pizza as a whole. Furthermore, if you take all the slices, or all the portions, together, you have the entire pizza.

## References

This repository would not have existed if I had not been insipred by the people who did things like that before me. I'm eternally grateful for efforts of others publishing resources online, and here is a list of just a select few that I've used over the years to become a better programmer.

- [CS academy - algos resource + useful graph visualisation tool](https://csacademy.com/)
- [Coding Interview University](https://github.com/jwasham/coding-interview-university)
- [5+5](https://www.reddit.com/r/learnprogramming/comments/gsansp/my_55step_selftaught_cs_curriculum_updated/)
- [Project-Based Learning](https://github.com/tuvtran/project-based-learning)
- [Let's Build a Compiler](https://compilers.iecc.com/crenshaw/)
- [OSSU](https://github.com/ossu/computer-science)
- [p1xt](https://github.com/P1xt/p1xt-guides/blob/master/README.md)
- [startup next door](https://startupnextdoor.com/)
- [computer stuff they didn't teach you](https://www.youtube.com/shanselman)
